<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Key Concepts in Docker</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
        h1, h2, h3 { color: #2c3e50; text-align: left; }
        ul { margin-left: 20px; }
        .container { max-width: 800px; margin: auto; }
        .section { margin-bottom: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Key Concepts in Docker</h1>
        <ol>
            <h3>1. Containerization</h3>
            <ul>
                <li>Docker enables you to package applications and their dependencies into containers, ensuring that they run consistently across different environments.</li>
                <li>Containers are lightweight and isolate applications from the underlying host system, reducing compatibility issues.</li>
            </ul>
            
            <h3>2. Docker Images</h3>
            <ul>
                <li>Docker images are read-only templates that define the contents of a container.</li>
                <li>Images are built using a Dockerfile and can be stored and shared via Docker Hub or private registries.</li>
                <li>Images can be stored and shared via Docker Hub or private registries.</li>
            </ul>
            
            <h3>3. Dockerfile</h3>
            <ul>
                <li>A script that defines how to build a Docker image.</li>
                <li>Key instructions: FROM, RUN, COPY, EXPOSE, CMD, ENTRYPOINT.
                <ul>
                  <li>FROM: Specifies the base image (e.g., FROM ubuntu:20.04).</li>
                  <li>RUN: Executes commands in the image (e.g., RUN apt-get install -y nginx).</li>
                  <li>COPY/ADD: Copies files from the local machine to the image.</li>
                  <li>EXPOSE: Defines the port the container will listen on.</li>
                  <li>CMD/ENTRYPOINT: Specifies the default command to run when the container starts.</li>
                </ul>
                </li>
            </ul>
            
            <h3>4. Docker Containers</h3>
            <ul>
                <li>A container is a running instance of a Docker image. It includes everything needed to run the application, such as code, runtime, and system tools.</li>
                <li>Containers are isolated from one another and the host but can communicate through networking.</li>
            </ul>
            
            <h3>5. Docker Registry</h3>
            <ul>
                <li>Docker images are stored in a registry (public or private). Docker Hub is the default public registry,
                  but you can also use private registries like AWS ECR, Google Container Registry, or on-premise solutions.</li>
                <li>Images can be tagged (e.g., myapp:1.0) and versioned for easy reference in different environments.</li>
            </ul>
            
            <h3>6. Volumes</h3>
            <ul>
                <li>Volumes are used to persist data generated or used by containers. Docker containers are ephemeral, 
                  so any data not stored in a volume will be lost when the container is stopped.</li>
                <li>Volumes allow data sharing between containers or between a container and the host.</li>
            </ul>
            
            <h3>7. Networking</h3>
            <ul>
                <li>Docker provides several networking options to manage communication between containers and external systems:
                <ul>
                  <li>Bridge: The default network for containers, allowing communication between containers on the same host.</li>
                  <li>Host: Shares the host's networking stack (used in specific scenarios where performance is critical).</li>
                  <li>Overlay: Enables containers running on different Docker hosts to communicate (used in Docker Swarm).</li>
                  <li>None: Isolates the container with no network access.</li>
                </ul>
                </li>
            </ul>
            
            <h3>8. Docker Compose</h3>
            <ul>
                <li>Docker Compose is a tool used to define and run multi-container applications using a simple YAML configuration file (docker-compose.yml).</li>
                <li>It allows you to start, stop, and manage multiple containers together (e.g., a web app, a database, and a cache).</li>
                <li>With Compose, you can define services, volumes, networks, and environment variables in one file, making orchestration easier.</li>
            </ul>
            
            <h3>9. Port Binding</h3>
            <ul>
                <li>Docker containers run in isolated environments, but you can bind their ports to the host to make the application accessible.</li>
                <li>For example, docker run -p 8080:80 binds the container's port 80 to the host's port 8080, allowing external access to the containerized app.</li>
            </ul>
            
            <h3>10. Docker Swarm</h3>
            <ul>
                <li>Docker Swarm is Dockerâ€™s native clustering and orchestration tool for managing a cluster of Docker hosts (nodes).</li>
                <li>It allows you to deploy, scale, and manage services across multiple nodes with load balancing and fault tolerance.</li>
            </ul>
            
            <h3>11. Dockerfile Best Practices</h3>
            <ul>
                <li><strong>Use minimal base images:</strong> Minimize image size by using lean images (e.g., alpine).</li>
                <li><strong>Layer caching:</strong> Docker caches image layers. Arrange the Dockerfile steps from least to most frequently changing to leverage caching efficiently.</li>
                <li><strong>Multi-stage builds:</strong> Use multi-stage builds to create lightweight production images by separating the build process from the final image.</li>
                <li><strong>Security:</strong> Avoid using the root user in the container and keep the number of open ports minimal.</li>
            </ul>
            
            <h3>12. Docker Engine</h3>
            <ul>
                <li>The Docker Engine is the core component that enables containerization. It consists of three parts:
                  <ul>
                    <li><strong>Docker Daemon:</strong> Runs on the host machine and manages containers and images.</li>
                    <li><strong>Docker CLI:</strong> Provides the command-line interface to interact with Docker.</li>
                    <li><strong>REST API:</strong> Allows other applications to communicate with the Docker Daemon programmatically.</li>
                  </ul>
               </li>
            </ul>
            
            <h3>13. Container Lifecycle</h3>
            <ul>
                <li>Containers have a lifecycle: create, start, stop, restart, kill, and remove.</li>
                <li>You can manage the container's lifecycle using commands like docker start, docker stop, docker restart, and docker rm.</li>
            </ul>
            
            <h3>14. Docker Logs</h3>
            <ul>
                <li>Docker provides logging for containers via <pre>docker logs <container_name>.</pre></li>
                <li>You can also configure Docker to forward logs to centralized log management tools like Fluentd, ELK stack, or AWS CloudWatch.</li>
            </ul>
            
            <h3>15. Resource Limits</h3>
            <ul>
                <li>Docker allows you to set resource limits on CPU and memory usage per container to prevent resource exhaustion on the host system.</li>
                <li>Use <pre>--memory</pre> and <pre>--cpus</pre> flags to limit the container's resource consumption.</li>
            </ul>
            
            <h3>16. Scaling</h3>
            <ul>
                <li>Docker makes it easy to scale applications by creating multiple container instances of the same service.</li>
                <li>Docker Swarm and Docker Compose support horizontal scaling, where you can run docker-compose up --scale <service>=n to scale services.</li>
            </ul>
            
            <h3>17. Security</h3>
            <ul>
                <li><strong>Isolation:</strong> Containers run in isolated environments, which enhances security, 
                  but containers share the host kernel, so security best practices are critical.</li>
                <li><strong>Least privilege:</strong> Avoid running containers with root privileges.</li>
                <li><strong>Image security:</strong> Use trusted base images and scan for vulnerabilities using tools like <strong>Docker Bench for Security</strong> or <strong>Clair.</strong></li>
            </ul>
            
            <h3>18. Docker in CI/CD</h3>
            <ul>
                <li>Docker can be integrated into CI/CD pipelines to ensure consistency across development, testing, and production environments.</li>
                <li>Build, test, and deploy containers automatically using CI/CD tools like Jenkins, GitLab CI, or CircleCI.</li>
            </ul>
            
            <h3>19. Docker vs Virtual Machines</h3>
            <ul>
                <li>Docker containers are lightweight and share the host OS kernel, while virtual machines (VMs)
                  include a full OS, making them heavier and slower to start.</li>
                <li>Containers are more efficient in terms of resource usage and boot times compared to VMs.</li>
            </ul>
            
            <h3>20. Kubernetes and Docker</h3>
            <ul>
                <li>Kubernetes is a popular container orchestration platform, often used with Docker for large-scale, multi-node container management.</li>
                <li>Kubernetes manages containerized applications across a cluster of machines, providing features like auto-scaling, self-healing, and load balancing.</li>
            </ul>
            
            <h3>Essential Docker Commands</h3>
            <ul>
                <li>docker build: Build an image from a Dockerfile.</li>
                <li>docker run: Run a container from an image.</li>
                <li>docker ps: List running containers.</li>
                <li>docker stop <container>: Stop a running container.</li>
                <li>docker exec <container> <command>: Run commands inside a running container.</li>
                <li>docker logs <container>: View logs of a container.</li>
                <li>docker pull/push: Download/upload images from/to a registry.</li>
        
            </ul>
        </ol>
    </div>
</body>
</html>
